kind: level
schema_version: 1

level_id: level-001-pipes-101
title: "Pipes 101: Count the Animals"
summary_md: "Learn a basic pipeline: sort → uniq -c → sort."
difficulty: 1
estimated_minutes: 5
tags: ["pipes", "sort", "uniq", "text"]
tool_focus: ["sort", "uniq"]

filesystem:
  dataset:
    source: dir
    path: "dataset"
    mount_point: "/levels/current"
    read_only: true
  work:
    mount_point: "/work"
    initial_layout:
      mkdirs: []
      copy_from_dataset:
        - from: "expected_animal_counts.txt"
          to: ".expected_animal_counts.txt"

objective:
  bullets:
    - "Read /levels/current/animals.txt"
    - "Create /work/animal_counts.txt with counts per animal, sorted by count DESC"
    - "When counts tie, either order is accepted for equal counts"
    - "Format each line as: COUNT<TAB>ANIMAL (tab-separated)"
  success_hint_md: |
    Nice. A canonical solution is:
    `sort | uniq -c | sort -nr | awk '{print $1 "\\t" $2}'`

hints:
  - hint_id: h1
    text_md: |
      Try a pipeline like:
      `sort animals.txt | uniq -c`
    unlock: { after_seconds: 0 }
  - hint_id: h2
    text_md: |
      `sort -nr` sorts by count descending.
      If ties differ, that's okay.
    unlock: { after_seconds: 45 }
  - hint_id: h3
    text_md: |
      `uniq -c` prefixes counts with spaces. Use awk to format with a TAB:
      `awk '{print $1 "\\t" $2}'`
    unlock: { after_seconds: 90 }

checks:
  - id: out_exists
    type: file_exists
    description: "Create /work/animal_counts.txt"
    required: true
    path: "/work/animal_counts.txt"
    on_fail_message: "No /work/animal_counts.txt found."

  - id: output_format_tab
    type: file_lines_match_regex
    description: "Each output line is tab-separated: COUNT<TAB>ANIMAL"
    required: true
    path: "/work/animal_counts.txt"
    pattern: "^\\d+\\t[[:alpha:]][[:alnum:]_-]*$"
    mode: all_lines
    on_fail_message: "Output lines must be formatted as COUNT<TAB>ANIMAL."

  - id: content_counts_match
    type: command_output_equals_file
    description: "Output matches expected counts (tie order ignored)"
    required: true
    command: |
      awk 'NF >= 2 {print $1 "\t" $2}' /work/animal_counts.txt \
        | sort -k1,1nr -k2,2
    compare_to_path: "/work/.expected_animal_counts.txt"
    timeout_seconds: 3
    normalize:
      newlines: any
      trim_trailing_whitespace: true
      trim_final_newline: true
    on_fail_message: "Your counts/format do not match expected."

  - id: no_useless_cat_bonus
    type: cmdlog_forbids_regex
    description: "Bonus: avoid useless cat (cat file | ...)"
    required: false
    points: 50
    pattern: "\\bcat\\s+\\S+\\s*\\|"
    on_fail_message: "You used a 'useless cat' pattern."

scoring:
  base_points: 1000
  time_grace_seconds: 60
  time_penalty_per_second: 1
  hint_penalty_points: 80
  reset_penalty_points: 120
  cmdlog_bonuses:
    - id: pipe_bonus
      description: "Used at least one pipe (|)"
      pattern: "\\|"
      points: 50

x-autocheck:
  mode: command_and_fs_debounce
  debounce_ms: 800
  quiet_fail: true

x-progression:
  tier: 1
  prerequisites: []
  mastery:
    min_score: 700
    max_hints: 3
    max_resets: 2

x-teaching:
  concepts: ["pipes", "sort", "uniq", "formatting"]
  review_days: [1, 3, 7]

reference_solutions:
  - solution_id: sol1
    title: "Canonical pipeline"
    script_sh: |
      sort /levels/current/animals.txt \
        | uniq -c \
        | sort -nr \
        | awk '{print $1 "\t" $2}' \
        > /work/animal_counts.txt
    explanation_md: "Sort groups identical lines, uniq counts them, sort orders by count descending, awk formats."
